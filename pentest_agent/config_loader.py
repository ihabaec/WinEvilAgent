import yaml
import os
import logging
from typing import Dict, List, Any

logger = logging.getLogger(__name__)

class YAMLConfigLoader:
    """
    Loads and manages YAML configuration files for enumeration and privilege escalation methods.
    Supports default methods and partial overrides.
    """

    def __init__(self, enum_file: str = 'enum.yaml', priv_file: str = 'priv.yaml'):
        self.enum_file = enum_file
        self.priv_file = priv_file
        self.enum_methods = []
        self.priv_methods = []
        self._load_configs()

    def _load_configs(self):
        """Load enumeration and privilege escalation methods from YAML files."""
        # Load enumeration methods
        self.enum_methods = self._load_and_merge_methods(
            self.enum_file,
            self._get_default_enum_methods(),
            "enumeration"
        )

        # Load privilege escalation methods
        self.priv_methods = self._load_and_merge_methods(
            self.priv_file,
            self._get_default_priv_methods(),
            "privilege escalation"
        )

    def _load_and_merge_methods(self, filepath: str, default_methods: List[Dict], method_type: str) -> List[Dict]:
        """
        Loads methods from a YAML file, validates them, and merges with defaults.
        Allows for partial overrides where methods with the same 'name' are updated.
        """
        loaded_methods = []
        if os.path.exists(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f)
                    if isinstance(data, dict) and 'methods' in data:
                        loaded_methods = data['methods']
                    elif isinstance(data, list):
                        loaded_methods = data
                    else:
                        logger.warning(f"⚠️  {filepath} has unexpected structure. Expected a list or dict with 'methods' key. Using default {method_type} methods.")
                        return default_methods
                
                # Basic schema validation for loaded methods
                validated_methods = []
                for method in loaded_methods:
                    if self._validate_method_schema(method, filepath):
                        validated_methods.append(method)
                    else:
                        logger.warning(f"Skipping invalid method in {filepath}: {method.get('name', 'N/A')}")
                
                logger.info(f"✅ Loaded {len(validated_methods)} {method_type} methods from {filepath}")
                
                # Merge logic: prioritize loaded methods, update defaults
                final_methods = {m['name']: m for m in default_methods}
                for method in validated_methods:
                    final_methods[method['name']] = method # Overwrite or add
                
                return list(final_methods.values())

            except yaml.YAMLError as e:
                logger.error(f"❌ YAML parsing error in {filepath}: {e}. Using default {method_type} methods.")
            except Exception as e:
                logger.error(f"❌ Error loading {filepath}: {e}. Using default {method_type} methods.")
        else:
            logger.warning(f"⚠️  {method_type.capitalize()} file {filepath} not found, using default methods.")
        
        return default_methods

    def _validate_method_schema(self, method: Dict, source: str) -> bool:
        """
        Performs basic schema validation for a method dictionary.
        A more robust solution would use a library like Pydantic or Cerberus.
        """
        required_keys = ['name', 'category', 'description', 'command']
        for key in required_keys:
            if key not in method or not method[key]:
                logger.error(f"Schema Error in {source}: Method '{method.get('name', 'N/A')}' missing or has empty required key: '{key}'")
                return False
        if not isinstance(method.get('indicators', []), list):
             logger.warning(f"Schema Warning in {source}: Method '{method.get('name', 'N/A')}' 'indicators' should be a list.")
        if not isinstance(method.get('priority', 0), int):
             logger.warning(f"Schema Warning in {source}: Method '{method.get('name', 'N/A')}' 'priority' should be an integer.")
        return True

    def _get_default_enum_methods(self) -> List[Dict]:
        """Default enumeration methods if YAML file is not found or fails to load."""
        return [
            {"name": "Current User", "category": "user_info", "description": "Get current user information", "command": "whoami", "indicators": ["\\"], "priority": 1},
            {"name": "User Privileges", "category": "privileges", "description": "Check current user privileges", "command": "whoami /priv", "indicators": ["SeDebugPrivilege", "SeTakeOwnershipPrivilege", "SeBackupPrivilege"], "priority": 1},
            {"name": "User Groups", "category": "group_membership", "description": "Check user group memberships", "command": "whoami /groups", "indicators": ["Administrators", "BUILTIN\\Administrators"], "priority": 1},
            {"name": "System Information", "category": "system_info", "description": "Get basic system information", "command": "systeminfo", "indicators": ["OS Name", "OS Version", "OS Build"], "priority": 2},
            {"name": "Network Configuration", "category": "network", "description": "Get network interface configuration", "command": "ipconfig /all", "indicators": ["IPv4 Address", "Default Gateway"], "priority": 2},
            {"name": "Running Processes", "category": "processes", "description": "List running processes", "command": "tasklist", "indicators": ["PID", "Image Name"], "priority": 3},
            {"name": "Installed Software", "category": "software", "description": "List installed programs via WMIC", "command": "wmic product get name,version", "indicators": ["Name", "Version"], "priority": 4}
        ]

    def _get_default_priv_methods(self) -> List[Dict]:
        """Default privilege escalation methods if YAML file is not found or fails to load."""
        return [
            {"name": "Service Enumeration", "category": "service_enum", "description": "Enumerate running services for unquoted paths or weak permissions", "command": "sc query type= service state= all | findstr \"SERVICE_NAME BINARY_PATH_NAME\"", "indicators": ["SERVICE_NAME", "BINARY_PATH_NAME"], "priority": 1},
            {"name": "Scheduled Tasks", "category": "scheduled_tasks", "description": "Enumerate scheduled tasks for potential abuse", "command": "schtasks /query /fo LIST /v", "indicators": ["TaskName", "Run As User", "Next Run Time"], "priority": 2},
            {"name": "Startup Programs Registry", "category": "registry_startup", "description": "Check startup programs in registry (HKLM)", "command": "reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /s", "indicators": ["REG_SZ", "REG_EXPAND_SZ"], "priority": 3},
            {"name": "Startup Programs Registry Current User", "category": "registry_startup", "description": "Check startup programs in registry (HKCU)", "command": "reg query HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /s", "indicators": ["REG_SZ", "REG_EXPAND_SZ"], "priority": 3},
            {"name": "Writable Directories", "category": "file_permissions", "description": "Find potentially writable directories for privilege escalation (C:\\)", "command": 'powershell -Command "Get-ChildItem -Path C:\\ -Recurse -Directory -ErrorAction SilentlyContinue | Where-Object { ($_.Attributes -notlike \\"*System*\\") -and ($_.Attributes -notlike \\"*Hidden*\\") } | Get-Acl | Where-Object { ($_.AccessToString -like \\"*Everyone Allow FullControl*\\") -or ($_.AccessToString -like \\"*Users Allow FullControl*\\") -or ($_.AccessToString -like \\"*Authenticated Users Allow FullControl*\\") } | Select-Object Path"', "indicators": ["Everyone", "FullControl", "Authenticated Users"], "priority": 4},
            {"name": "Installed Hotfixes", "category": "hotfixes", "description": "List installed hotfixes for known vulnerabilities", "command": "wmic qfe get Caption,HotFixID,InstalledOn", "indicators": ["HotFixID", "InstalledOn"], "priority": 5}
        ]

    def get_methods_by_category(self, category: str, method_type: str = 'enum') -> List[Dict]:
        """Get methods filtered by category."""
        methods = self.enum_methods if method_type == 'enum' else self.priv_methods
        return [method for method in methods if method.get('category') == category]

    def get_all_methods(self, method_type: str = 'enum') -> List[Dict]:
        """Get all methods of specified type."""
        return self.enum_methods if method_type == 'enum' else self.priv_methods

    def get_methods_by_priority(self, max_priority: int = 5, method_type: str = 'enum') -> List[Dict]:
        """Get methods filtered by priority (lower number = higher priority)."""
        methods = self.enum_methods if method_type == 'enum' else self.priv_methods
        return [method for method in methods if method.get('priority', 5) <= max_priority]
import winrm
from typing import Dict
import logging
import time

logger = logging.getLogger(__name__)

class WinRMConnection:
    """Handles WinRM connection and command execution with basic retry logic."""

    def __init__(self, host: str, username: str, password: str, port: int = 5985):
        self.host = host
        self.username = username
        self.password = password
        self.port = port
        self.session = None
        self.connect()

    def connect(self):
        """Establish WinRM connection."""
        try:
            endpoint = f'http://{self.host}:{self.port}/wsman'
            self.session = winrm.Session(endpoint, auth=(self.username, self.password), transport='ntlm')
            logger.info(f"✅ Connected to {self.host}:{self.port}")
        except Exception as e:
            logger.error(f"❌ Connection failed to {self.host}:{self.port}: {e}")
            raise

    def run_command(self, command: str, retries: int = 3, delay: int = 2) -> Dict:
        """
        Runs a command with retries for transient failures.
        Returns a dictionary with status, stdout, stderr, and success.
        """
        if not self.session:
            logger.error("No active WinRM session.")
            return {
                'status': -1,
                'stdout': '',
                'stderr': 'No active WinRM session.',
                'success': False
            }

        for attempt in range(retries):
            try:
                logger.debug(f"Executing command (Attempt {attempt + 1}/{retries}): {command[:100]}...")
                result = self.session.run_cmd(command)
                success = result.status_code == 0
                stdout = result.std_out.decode('latin-1').strip()
                stderr = result.std_err.decode('latin-1').strip()

                if success:
                    logger.debug(f"Command successful: {command[:50]}...")
                    return {
                        'status': result.status_code,
                        'stdout': stdout,
                        'stderr': stderr,
                        'success': True
                    }
                else:
                    logger.warning(f"Command failed (Status {result.status_code}): {command[:50]}... StdErr: {stderr[:100]}")
                    # For non-zero status codes, it might not be a transient error.
                    # Only retry if it's a known transient error pattern or generic communication failure.
                    # For simplicity, we'll retry all failures for now.
                    if attempt < retries - 1:
                        logger.info(f"Retrying in {delay} seconds...")
                        time.sleep(delay)
                        delay *= 2 # Exponential backoff
            except winrm.exceptions.WinRMOperationTimeoutError as e:
                logger.warning(f"WinRM operation timed out: {e}. Retrying...")
                if attempt < retries - 1:
                    time.sleep(delay)
                    delay *= 2
            except winrm.exceptions.WinRMTransportError as e:
                logger.warning(f"WinRM transport error: {e}. Retrying...")
                if attempt < retries - 1:
                    time.sleep(delay)
                    delay *= 2
            except Exception as e:
                logger.error(f"An unexpected error occurred during command execution: {e}")
                # Don't retry for unknown critical errors immediately
                return {
                    'status': -1,
                    'stdout': '',
                    'stderr': str(e),
                    'success': False
                }

        # If all retries fail
        logger.error(f"Command failed after {retries} attempts: {command[:100]}...")
        return {
            'status': result.status_code if 'result' in locals() else -1,
            'stdout': stdout if 'stdout' in locals() else '',
            'stderr': stderr if 'stderr' in locals() else 'Command failed after multiple retries.',
            'success': False
        }
import logging
import os
import time
import random
import json
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass, asdict
from enum import Enum

# Import modularized components
from .winrm_client import WinRMConnection
from .security_checker import SecurityChecker
from .config_loader import YAMLConfigLoader
from .ai_assistant import AIAssistant

logger = logging.getLogger(__name__)

class AttackPhase(Enum):
    RECONNAISSANCE = "reconnaissance"
    INITIAL_ACCESS = "initial_access"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PERSISTENCE = "persistence"
    OBJECTIVE_COMPLETION = "objective_completion"

@dataclass
class SystemContext:
    """Represents the current understanding of the target system"""
    os_version: str = ""
    architecture: str = ""
    domain_status: str = ""
    current_user: str = ""
    user_privileges: List[str] = None
    installed_software: List[str] = None
    running_services: List[str] = None
    network_info: Dict = None
    security_products: List[str] = None
    file_permissions: Dict = None
    registry_access: Dict = None
    scheduled_tasks: List[str] = None
    vulnerabilities: List[str] = None
    attack_vectors: List[str] = None
    
    def __post_init__(self):
        if self.user_privileges is None:
            self.user_privileges = []
        if self.installed_software is None:
            self.installed_software = []
        if self.running_services is None:
            self.running_services = []
        if self.network_info is None:
            self.network_info = {}
        if self.security_products is None:
            self.security_products = []
        if self.file_permissions is None:
            self.file_permissions = {}
        if self.registry_access is None:
            self.registry_access = {}
        if self.scheduled_tasks is None:
            self.scheduled_tasks = []
        if self.vulnerabilities is None:
            self.vulnerabilities = []
        if self.attack_vectors is None:
            self.attack_vectors = []

@dataclass
class ActionResult:
    """Represents the result of an action taken by the agent"""
    command: str
    success: bool
    output: str
    error: str
    context_updates: Dict = None
    discovered_vectors: List[str] = None
    phase_completion: bool = False
    
    def __post_init__(self):
        if self.context_updates is None:
            self.context_updates = {}
        if self.discovered_vectors is None:
            self.discovered_vectors = []

class ContextAnalyzer:
    """Analyzes system context and identifies attack vectors"""
    
    def __init__(self, connection: WinRMConnection, security: SecurityChecker):
        self.connection = connection
        self.security = security
        self.context = SystemContext()
        
    def analyze_basic_system_info(self) -> SystemContext:
        """Gather basic system information"""
        logger.info("üîç Analyzing basic system information...")
        
        # Get OS version
        result = self.connection.run_command("systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\"")
        if result['success']:
            self.context.os_version = result['stdout'].strip()
        
        # Get architecture
        result = self.connection.run_command("echo %PROCESSOR_ARCHITECTURE%")
        if result['success']:
            self.context.architecture = result['stdout'].strip()
        
        # Get current user and privileges
        result = self.connection.run_command("whoami /all")
        if result['success']:
            self.context.current_user = self._extract_current_user(result['stdout'])
            self.context.user_privileges = self._extract_privileges(result['stdout'])
        
        # Check domain status
        result = self.connection.run_command("systeminfo | findstr /B /C:\"Domain\"")
        if result['success']:
            self.context.domain_status = result['stdout'].strip()
        
        return self.context
    
    def analyze_software_and_services(self) -> List[str]:
        """Analyze installed software and running services"""
        logger.info("üîç Analyzing installed software and services...")
        
        attack_vectors = []
        
        # Get installed software
        result = self.connection.run_command("wmic product get name,version /format:csv")
        if result['success']:
            self.context.installed_software = self._parse_installed_software(result['stdout'])
            attack_vectors.extend(self._identify_software_vulnerabilities(self.context.installed_software))
        
        # Get running services
        result = self.connection.run_command("sc query state= all")
        if result['success']:
            self.context.running_services = self._parse_running_services(result['stdout'])
            attack_vectors.extend(self._identify_service_vulnerabilities(self.context.running_services))
        
        return attack_vectors
    
    def _parse_network_info(self, output: str) -> Dict:
        """Basic parser for ipconfig /all output into a structured dict"""
        network_info = {}
        current_adapter = None

        for line in output.splitlines():
            line = line.strip()
            if not line:
                continue

            # Identify a new adapter section
            if line.endswith(":") and "adapter" in line.lower():
                current_adapter = line.rstrip(":")
                network_info[current_adapter] = {}
                continue

            # Key-value entries
            if ":" in line and current_adapter:
                key, value = map(str.strip, line.split(":", 1))
                network_info[current_adapter][key] = value

        return network_info

    
    def analyze_network_configuration(self) -> List[str]:
        """Analyze network configuration for attack vectors"""
        logger.info("üîç Analyzing network configuration...")
        
        attack_vectors = []
        
        # Get network configuration
        result = self.connection.run_command("ipconfig /all")
        if result['success']:
            self.context.network_info = self._parse_network_info(result['stdout'])
        
        # Check for interesting network services
        result = self.connection.run_command("netstat -ano")
        if result['success']:
            listening_ports = self._parse_listening_ports(result['stdout'])
            attack_vectors.extend(self._analyze_listening_ports(listening_ports))
        
        return attack_vectors
    def _parse_file_permissions(self, icacls_output: str) -> Dict[str, List[str]]:
        """Parse icacls output into a dict mapping users/groups to their permissions."""
        permissions = {}

        for line in icacls_output.splitlines():
            if ":" not in line:
                continue

            parts = line.strip().split(":")
            if len(parts) < 2:
                continue

            user_or_group = parts[0].strip()
            perms = parts[1].strip().strip("()").split(",")

            permissions[user_or_group] = [p.strip() for p in perms if p.strip()]

        return permissions

    def analyze_file_permissions(self) -> List[str]:
        """Analyze file permissions for privilege escalation vectors"""
        logger.info("üîç Analyzing file permissions...")
        
        attack_vectors = []
        
        # Check common writable directories
        writable_dirs = [
            "C:\\Program Files",
            "C:\\Program Files (x86)",
            "C:\\Windows\\System32",
            "C:\\Windows\\Temp",
            "C:\\Temp"
        ]
        
        for directory in writable_dirs:
            result = self.connection.run_command(f"icacls \"{directory}\" 2>nul")
            if result['success']:
                permissions = self._parse_file_permissions(result['stdout'])
                self.context.file_permissions[directory] = permissions
                if self._is_writable_by_user(permissions, self.context.current_user):
                    attack_vectors.append(f"writable_directory:{directory}")
        
        return attack_vectors

    def _is_writable_by_user(self, permissions: Dict[str, List[str]], user: str) -> bool:
        """Check if user or 'Everyone' has write permissions"""
        for principal, perms in permissions.items():
            principal = principal.lower()
            if user.lower() in principal or "everyone" in principal:
                for perm in perms:
                    if any(p in perm.upper() for p in ['W', 'M', 'F']):  # Write, Modify, Full
                        return True
        return False

    def analyze_scheduled_tasks(self) -> List[str]:
        """Analyze scheduled tasks for privilege escalation"""
        logger.info("üîç Analyzing scheduled tasks...")
        
        attack_vectors = []
        
        result = self.connection.run_command("schtasks /query /fo csv /v")
        if result['success']:
            self.context.scheduled_tasks = self._parse_scheduled_tasks(result['stdout'])
            attack_vectors.extend(self._identify_task_vulnerabilities(self.context.scheduled_tasks))
        
        return attack_vectors
    
    def _extract_current_user(self, whoami_output: str) -> str:
        """Extract current user from whoami output"""
        lines = whoami_output.split('\n')
        for line in lines:
            if 'User Name' in line:
                return line.split()[-1] if line.split() else ""
        return ""
    
    def _extract_privileges(self, whoami_output: str) -> List[str]:
        """Extract user privileges from whoami output"""
        privileges = []
        in_privileges_section = False
        
        for line in whoami_output.split('\n'):
            if 'PRIVILEGES INFORMATION' in line:
                in_privileges_section = True
                continue
            
            if in_privileges_section and line.strip():
                if line.startswith('Privilege Name'):
                    continue
                parts = line.split()
                if parts:
                    privileges.append(parts[0])
        
        return privileges
    
    def _parse_installed_software(self, wmic_output: str) -> List[str]:
        """Parse installed software from WMIC output"""
        software = []
        for line in wmic_output.split('\n'):
            if line.strip() and 'Name' not in line:
                parts = line.split(',')
                if len(parts) >= 2 and parts[1].strip():
                    software.append(parts[1].strip())
        return software
    
    def _parse_running_services(self, sc_output: str) -> List[str]:
        """Parse running services from SC output"""
        services = []
        for line in sc_output.split('\n'):
            if 'SERVICE_NAME:' in line:
                service_name = line.split(':')[1].strip()
                services.append(service_name)
        return services
    
    def _identify_software_vulnerabilities(self, software: List[str]) -> List[str]:
        """Identify potential vulnerabilities in installed software"""
        vulnerabilities = []
        
        # Known vulnerable software patterns
        vulnerable_patterns = {
            'java': 'java_vulnerability',
            'adobe': 'adobe_vulnerability',
            'flash': 'flash_vulnerability',
            'office': 'office_vulnerability'
        }
        
        for sw in software:
            for pattern, vuln_type in vulnerable_patterns.items():
                if pattern.lower() in sw.lower():
                    vulnerabilities.append(f"{vuln_type}:{sw}")
        
        return vulnerabilities
    
    def _identify_service_vulnerabilities(self, services: List[str]) -> List[str]:
        """Identify potential service vulnerabilities"""
        vulnerabilities = []
        
        # Known vulnerable services
        vulnerable_services = {
            'unquoted_service_path': ['service with spaces'],
            'weak_service_permissions': ['custom_service'],
            'dll_hijacking': ['service_dll']
        }
        
        for service in services:
            # Check for unquoted service paths
            result = self.connection.run_command(f"sc qc {service}")
            if result['success'] and 'BINARY_PATH_NAME' in result['stdout']:
                binary_path = result['stdout']
                if ' ' in binary_path and not binary_path.startswith('"'):
                    vulnerabilities.append(f"unquoted_service_path:{service}")
        
        return vulnerabilities

    def _parse_listening_ports(self, netstat_output: str) -> List[Dict]:
        """Parse netstat output to extract listening ports"""
        ports = []

        for line in netstat_output.splitlines():
            line = line.strip()
            if not line or not "LISTENING" in line.upper():
                continue

            # Typical format: TCP    0.0.0.0:80     0.0.0.0:0     LISTENING     1234
            parts = line.split()
            if len(parts) >= 5:
                protocol = parts[0]
                local_address = parts[1]
                pid = parts[-1]

                ip, port = local_address.rsplit(":", 1) if ":" in local_address else (local_address, "unknown")

                ports.append({
                    "protocol": protocol,
                    "ip": ip,
                    "port": port,
                    "pid": pid
                })

        return ports

    def _analyze_listening_ports(self, ports: List[Dict]) -> List[str]:
        """Analyze listening ports for common exploitation opportunities"""
        vectors = []

        # Common high-value services that are useful to attack
        known_ports = {
            "135": "RPC Endpoint Mapper",
            "139": "NetBIOS Session Service",
            "445": "SMB",
            "3389": "RDP",
            "5985": "WinRM HTTP",
            "5986": "WinRM HTTPS",
            "80": "HTTP",
            "443": "HTTPS"
        }

        for entry in ports:
            port = entry.get("port")
            desc = known_ports.get(port)
            if desc:
                vectors.append(f"exposed_service:{port} ({desc})")
            else:
                vectors.append(f"open_port:{port}")

        return vectors


class PentestAgent:
    """
    Enhanced penetration testing agent with context analysis and memory
    """
    
    def __init__(self, config_file: str = '.env', enum_file: Optional[str] = None, priv_file: Optional[str] = None):
        from dotenv import load_dotenv
        load_dotenv(config_file)
        
        self.connection = WinRMConnection(
            host=os.getenv('TARGET_HOST'),
            username=os.getenv('TARGET_USER'),
            password=os.getenv('TARGET_PASS')
        )

        self.ai = AIAssistant(os.getenv('GROQ_API_KEY'))
        self.security = SecurityChecker()
        self.analyzer = ContextAnalyzer(self.connection, self.security)
        
        self.current_phase = AttackPhase.RECONNAISSANCE
        self.action_history: List[ActionResult] = []
        self.discovered_vectors: List[str] = []
        self.objective_achieved = False
        
        # Memory system
        self.memory = {
            'successful_commands': [],
            'failed_commands': [],
            'context_updates': [],
            'phase_transitions': []
        }
        
    def run(self):
        """Main execution loop with intelligent decision making"""
        logger.info("üöÄ Starting Intelligent Penetration Testing Agent")
        logger.info("üéØ Objective: Gain administrator privileges and create C:\\Windows\\System32\\rooted")
        logger.info("=" * 70)
        
        try:
            while not self.objective_achieved:
                logger.info(f"\nüìç Current Phase: {self.current_phase.value.upper()}")
                
                if self.current_phase == AttackPhase.RECONNAISSANCE:
                    self._execute_reconnaissance_phase()
                    
                elif self.current_phase == AttackPhase.PRIVILEGE_ESCALATION:
                    self._execute_privilege_escalation_phase()
                    
                elif self.current_phase == AttackPhase.OBJECTIVE_COMPLETION:
                    self._execute_objective_completion_phase()
                    
                else:
                    logger.error(f"Unknown phase: {self.current_phase}")
                    break
                    
            if self.objective_achieved:
                logger.info("üéâ OBJECTIVE ACHIEVED! Administrator privileges gained and rooted file created.")
            else:
                logger.error("‚ùå Failed to achieve objective.")
                
        except Exception as e:
            logger.exception(f"‚ùå Unexpected error: {e}")
    
    def _execute_reconnaissance_phase(self):
        """Execute reconnaissance phase with context analysis"""
        logger.info("üîç Executing reconnaissance phase...")
        
        # Gather basic system information
        self.analyzer.analyze_basic_system_info()
        
        # Analyze software and services
        software_vectors = self.analyzer.analyze_software_and_services()
        self.discovered_vectors.extend(software_vectors)
        
        # Analyze network configuration
        network_vectors = self.analyzer.analyze_network_configuration()
        self.discovered_vectors.extend(network_vectors)
        
        # Analyze file permissions
        file_vectors = self.analyzer.analyze_file_permissions()
        self.discovered_vectors.extend(file_vectors)
        
        # Analyze scheduled tasks
        task_vectors = self.analyzer.analyze_scheduled_tasks()
        self.discovered_vectors.extend(task_vectors)
        
        # Update context with discovered attack vectors
        self.analyzer.context.attack_vectors = self.discovered_vectors
        
        logger.info(f"üìä Reconnaissance complete. Discovered {len(self.discovered_vectors)} potential attack vectors.")
        
        # Check if already admin
        if self._check_admin_privileges():
            logger.info("‚úÖ Already have administrator privileges!")
            self.current_phase = AttackPhase.OBJECTIVE_COMPLETION
        else:
            self.current_phase = AttackPhase.PRIVILEGE_ESCALATION
    
    def _execute_privilege_escalation_phase(self):
        """Execute privilege escalation using AI decision making"""
        logger.info("üî• Executing privilege escalation phase...")
        
        max_attempts = 15
        attempt = 0
        
        while attempt < max_attempts and not self._check_admin_privileges():
            attempt += 1
            logger.info(f"\n--- Escalation Attempt {attempt}/{max_attempts} ---")
            
            # Get AI suggestion based on current context
            suggestion = self._get_ai_escalation_suggestion()
            
            if not suggestion:
                logger.error("‚ùå AI failed to provide suggestion. Trying next attempt.")
                continue
            
            command = suggestion.get('command')
            reasoning = suggestion.get('reasoning', 'No reasoning provided')
            
            logger.info(f"üß† AI Suggestion: {command}")
            logger.info(f"üí≠ Reasoning: {reasoning}")
            
            # Execute the suggested command
            result = self._execute_command_with_analysis(command, reasoning)
            
            if result and result.phase_completion:
                logger.info("‚úÖ Phase completion detected!")
                break
            
            # Add delay between attempts
            time.sleep(2 + random.uniform(0, 1))
        
        if self._check_admin_privileges():
            logger.info("üèÜ Administrator privileges achieved!")
            self.current_phase = AttackPhase.OBJECTIVE_COMPLETION
        else:
            logger.error("‚ùå Failed to achieve administrator privileges.")
    
    def _execute_objective_completion_phase(self):
        """Execute the final objective - create rooted file"""
        logger.info("üéØ Executing objective completion phase...")
        
        # Create the rooted directory in System32
        rooted_path = "C:\\Windows\\System32\\rooted"
        
        # Use multiple approaches to ensure success
        commands = [
            f'mkdir "{rooted_path}"',
            f'powershell -Command "New-Item -ItemType Directory -Path \\"{rooted_path}\\" -Force"',
            f'md "{rooted_path}"'
        ]
        
        for cmd in commands:
            logger.info(f"üîß Attempting: {cmd}")
            result = self.connection.run_command(cmd)
            
            if result['success'] or "already exists" in result['stderr'].lower():
                logger.info("‚úÖ Rooted directory created successfully!")
                
                # Verify creation
                verify_result = self.connection.run_command(f'dir "{rooted_path}"')
                if verify_result['success']:
                    logger.info("üéâ OBJECTIVE ACHIEVED! Rooted directory verified.")
                    self.objective_achieved = True
                    return
                
        logger.error("‚ùå Failed to create rooted directory.")
    
    def _get_ai_escalation_suggestion(self) -> Optional[Dict]:
        """Get AI suggestion for privilege escalation"""
        # Prepare context for AI
        context_summary = self._prepare_context_for_ai()
        
        # Get AI suggestion
        suggestion = self.ai.get_escalation_suggestion(
            context=context_summary,
            attack_vectors=self.discovered_vectors,
            previous_attempts=self._get_recent_attempts(),
            objective="Gain administrator privileges on Windows system"
        )
        
        return suggestion
    
    def _prepare_context_for_ai(self) -> str:
        """Prepare context summary for AI analysis"""
        context = self.analyzer.context
        
        summary_parts = []
        
        # System information
        summary_parts.append(f"System: {context.os_version}")
        summary_parts.append(f"Architecture: {context.architecture}")
        summary_parts.append(f"Current User: {context.current_user}")
        summary_parts.append(f"Domain Status: {context.domain_status}")
        
        # Privileges
        if context.user_privileges:
            summary_parts.append(f"User Privileges: {', '.join(context.user_privileges[:5])}")
        
        # Software
        if context.installed_software:
            summary_parts.append(f"Key Software: {', '.join(context.installed_software[:10])}")
        
        # Services
        if context.running_services:
            summary_parts.append(f"Running Services: {len(context.running_services)} services detected")
        
        # Attack vectors
        if self.discovered_vectors:
            summary_parts.append(f"Discovered Attack Vectors: {', '.join(self.discovered_vectors[:5])}")
        
        return "\n".join(summary_parts)
    
    def _get_recent_attempts(self) -> List[str]:
        """Get recent command attempts for AI context"""
        recent_attempts = []
        for action in self.action_history[-10:]:  # Last 10 attempts
            status = "SUCCESS" if action.success else "FAILED"
            recent_attempts.append(f"{action.command} - {status}")
        return recent_attempts
    
    def _execute_command_with_analysis(self, command: str, reasoning: str) -> Optional[ActionResult]:
        """Execute command and analyze results"""
        if not self.security.is_safe_command(command):
            logger.warning(f"‚ùå Command blocked by safety check: {command}")
            return None
        
        result = self.connection.run_command(command)
        
        # Create action result
        action_result = ActionResult(
            command=command,
            success=result['success'],
            output=result['stdout'],
            error=result['stderr'],
            context_updates={},
            discovered_vectors=[]
        )
        
        # Analyze the result for context updates
        if result['success']:
            logger.info("‚úÖ Command executed successfully")
            
            # Check for privilege escalation indicators
            if self._check_admin_privileges():
                action_result.phase_completion = True
                logger.info("üèÜ Administrator privileges detected!")
            
            # Look for new attack vectors in output
            new_vectors = self._analyze_output_for_vectors(result['stdout'])
            action_result.discovered_vectors = new_vectors
            self.discovered_vectors.extend(new_vectors)
            
        else:
            logger.warning(f"‚ùå Command failed: {result['stderr']}")
        
        # Store in memory
        self.action_history.append(action_result)
        self._update_memory(action_result)
        
        return action_result
    
    def _analyze_output_for_vectors(self, output: str) -> List[str]:
        """Analyze command output for new attack vectors"""
        vectors = []
        
        # Look for common privilege escalation indicators
        indicators = {
            'unquoted_service_path': ['BINARY_PATH_NAME', 'Program Files'],
            'weak_service_permissions': ['SERVICE_ALL_ACCESS', 'SERVICE_CHANGE_CONFIG'],
            'dll_hijacking': ['.dll', 'LoadLibrary'],
            'token_impersonation': ['SeImpersonatePrivilege', 'SeAssignPrimaryTokenPrivilege'],
            'backup_operators': ['SeBackupPrivilege', 'SeRestorePrivilege']
        }
        
        for vector_type, keywords in indicators.items():
            for keyword in keywords:
                if keyword.lower() in output.lower():
                    vectors.append(f"{vector_type}:{keyword}")
        
        return vectors
    
    def _check_admin_privileges(self) -> bool:
        """Check if current user has administrator privileges"""
        # Multiple checks for admin privileges
        checks = [
            'net localgroup administrators',
            'whoami /groups | findstr "S-1-5-32-544"',
            'fsutil dirty query c: 2>nul'
        ]
        
        for check in checks:
            result = self.connection.run_command(check)
            if result['success']:
                output = result['stdout'].lower()
                current_user = self.analyzer.context.current_user.lower()
                
                if any(indicator in output for indicator in [current_user, 'administrators', 'enabled']):
                    return True
        
        return False
    
    def _update_memory(self, action_result: ActionResult):
        """Update the agent's memory with new information"""
        if action_result.success:
            self.memory['successful_commands'].append({
                'command': action_result.command,
                'output_length': len(action_result.output),
                'discovered_vectors': action_result.discovered_vectors
            })
        else:
            self.memory['failed_commands'].append({
                'command': action_result.command,
                'error': action_result.error
            })
        
        if action_result.context_updates:
            self.memory['context_updates'].append(action_result.context_updates)
    
    def get_memory_summary(self) -> Dict:
        """Get a summary of the agent's memory for debugging"""
        return {
            'successful_commands': len(self.memory['successful_commands']),
            'failed_commands': len(self.memory['failed_commands']),
            'context_updates': len(self.memory['context_updates']),
            'discovered_vectors': len(self.discovered_vectors),
            'current_phase': self.current_phase.value,
            'objective_achieved': self.objective_achieved
        }
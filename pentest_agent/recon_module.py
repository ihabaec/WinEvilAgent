import logging
from typing import Dict, List, Optional
from .winrm_client import WinRMConnection
from .security_checker import SecurityChecker
from .config_loader import YAMLConfigLoader

logger = logging.getLogger(__name__)

class ReconModule:
    """Reconnaissance commands using YAML configuration."""

    def __init__(self, config_loader: YAMLConfigLoader):
        self.config_loader = config_loader

    def get_basic_info(self, connection: WinRMConnection) -> Dict:
        """Get basic system information using configured methods."""
        enum_methods = self.config_loader.get_methods_by_priority(max_priority=2, method_type='enum')
        results = {}

        for method in enum_methods:
            method_name = method['name'].lower().replace(' ', '_')
            logger.info(f"Running basic info method: {method['name']}...")

            result = connection.run_command(method['command'])
            results[method_name] = {
                **result,
                'method_info': method
            }
        return results

    def run_enumeration_by_category(self, connection: WinRMConnection, category: str) -> Dict:
        """Run enumeration methods for a specific category."""
        methods = self.config_loader.get_methods_by_category(category, 'enum')
        results = {}

        logger.info(f"\nðŸ” Running {category} enumeration...")
        for method in methods:
            method_name = method['name'].lower().replace(' ', '_')
            logger.info(f"  â€¢ {method['name']}: {method['description']}")

            result = connection.run_command(method['command'])
            results[method_name] = {
                **result,
                'method_info': method
            }

            if result['success']:
                found_indicators = []
                for indicator in method.get('indicators', []):
                    if indicator.lower() in result['stdout'].lower():
                        found_indicators.append(indicator)

                if found_indicators:
                    logger.info(f"    âœ… Found indicators: {', '.join(found_indicators)}")
                else:
                    logger.info(f"    â„¹ï¸  Command executed successfully, no specific indicators found.")
            else:
                logger.warning(f"    âŒ Command failed: {result['stderr'][:50]}...")
        return results

class BatchModule:
    """Handles batch operations for enumeration and privilege escalation."""

    def __init__(self, connection: WinRMConnection, security: SecurityChecker, recon: ReconModule, config_loader: YAMLConfigLoader):
        self.connection = connection
        self.security = security
        self.recon = recon
        self.config_loader = config_loader

    def run_enumeration_batch(self, max_attempts: int = 20) -> Dict:
        """Run automated enumeration using YAML configuration."""
        logger.info("\nðŸ” Starting automated enumeration batch mode...")
        logger.info("=" * 60)

        results = {
            "total_attempts": 0,
            "successful": [],
            "failed": [],
            "findings": {},
            "categories_covered": set(),
            "potential_vectors": [] 
        }

        enum_methods = self.config_loader.get_all_methods('enum')
        sorted_methods = sorted(enum_methods, key=lambda x: x.get('priority', 5))

        for i, method in enumerate(sorted_methods):
            if i >= max_attempts:
                logger.info(f"Max enumeration attempts ({max_attempts}) reached.")
                break

            logger.info(f"\n[{i+1}/{min(len(sorted_methods), max_attempts)}] {method['name']}")
            logger.debug(f"Category: {method['category']}, Priority: {method['priority']}")
            logger.debug(f"Description: {method['description']}")
            logger.debug(f"Command: {method['command']}")

            if not self.security.is_safe_command(method['command']):
                logger.warning("âŒ Command blocked by safety check.")
                results["failed"].append({"method": method, "reason": "blocked_by_safety_check"})
                continue

            result = self.connection.run_command(method['command'])
            results["total_attempts"] += 1
            results["categories_covered"].add(method['category'])

            if result['success']:
                logger.info("âœ… Command executed successfully.")

                found_indicators = []
                for indicator in method.get('indicators', []):
                    if indicator.lower() in result['stdout'].lower():
                        found_indicators.append(indicator)

                if found_indicators:
                    logger.info(f"ðŸŽ¯ Found indicators: {', '.join(found_indicators)}")
                    if method['category'] not in results["findings"]:
                        results["findings"][method['category']] = []
                    results["findings"][method['category']].append({
                        "method": method,
                        "indicators": found_indicators,
                        "output": result['stdout']
                    })

                output_preview = result['stdout'][:200].replace('\n', ' ') + "..." if len(result['stdout']) > 200 else result['stdout'].replace('\n', ' ')
                logger.debug(f"Output preview: {output_preview}")
                results["successful"].append({"method": method, "result": result})
            else:
                logger.warning("âŒ Command failed.")
                logger.warning(f"Error: {result['stderr'][:100]}..." if result['stderr'] else "No error output")
                results["failed"].append({"method": method, "result": result})
        
        logger.info(f"Enumeration batch completed. Total successful: {len(results['successful'])}, Failed: {len(results['failed'])}")
        return results

    def _analyze_and_prioritize_methods(self, methods: List[Dict], enum_results: Dict) -> List[Dict]:
        """Analyze enumeration results and prioritize privilege escalation methods."""
        prioritized_methods = []

        for method in methods:
            method_copy = method.copy()
            method_copy["score"] = method.get("priority", 5)  # Base score from priority

            # Adjust score based on enumeration findings
            category = method.get("category", "")

            # Check if enumeration found relevant indicators for this method
            if category in enum_results.get("findings", {}):
                logger.debug(f"Prioritizing {method_copy['name']} due to relevant enum findings in category {category}.")
                method_copy["score"] -= 1

            # Specific category adjustments (can be more complex)
            if category == "service_enum" and any("service" in c.lower() for c in enum_results.get("categories_covered", set())):
                method_copy["score"] -= 1
            elif category == "scheduled_tasks" and any("task" in c.lower() for c in enum_results.get("categories_covered", set())):
                method_copy["score"] -= 1
            elif category == "registry_startup" and any("registry" in c.lower() for c in enum_results.get("categories_covered", set())):
                method_copy["score"] -= 1
            
            prioritized_methods.append(method_copy)

        # Sort by score (lower is better)
        sorted_methods = sorted(prioritized_methods, key=lambda x: x["score"])
        logger.debug(f"Prioritized methods: {[m['name'] for m in sorted_methods]}")
        return sorted_methods

    def check_admin_privileges(self, connection: WinRMConnection, current_context: Optional[str] = None) -> bool:
        """
        Performs a definitive check for administrator privileges.
        Can optionally use provided context for an initial guess before running commands.
        """
        logger.info("Performing definitive administrator privilege check...")
        
        # Quick check if context already indicates admin
        if current_context and ("administrators" in current_context.lower() or "sedebugprivilege" in current_context.lower()):
            logger.debug("Context indicates potential admin privileges. Confirming...")

        # 1. Check groups (most reliable)
        group_check_result = connection.run_command("whoami /groups")
        if group_check_result['success']:
            output = group_check_result['stdout'].lower()
            if "builtin\\administrators" in output or "administrators" in output:
                logger.info("âœ… 'whoami /groups' confirms Administrator membership.")
                return True
        else:
            logger.warning(f"'whoami /groups' failed: {group_check_result['stderr']}")

        # 2. Check privileges (SeDebugPrivilege is a strong indicator)
        priv_check_result = connection.run_command("whoami /priv")
        if priv_check_result['success']:
            output = priv_check_result['stdout'].lower()
            if "sedebugprivilege" in output and "enabled" in output:
                logger.info("âœ… 'whoami /priv' confirms SeDebugPrivilege is enabled.")
                return True
        else:
            logger.warning(f"'whoami /priv' failed: {priv_check_result['stderr']}")

        logger.info("âŒ Administrator privileges NOT confirmed by definitive checks.")
        return False

    def analyze_results(self, results: Dict) -> Dict:
        """Analyze batch results and provide recommendations."""
        logger.info("\nðŸ“Š Batch Analysis Results:")
        logger.info("=" * 40)

        analysis = {
            "summary": {
                "total_attempts": results["total_attempts"],
                "successful_commands": len(results["successful"]),
                "failed_commands": len(results["failed"]),
                "potential_vectors": len(results.get("potential_vectors", [])),
                "categories_covered": len(results.get("categories_covered", set()))
            },
            "recommendations": []
        }

        logger.info(f"Total attempts: {analysis['summary']['total_attempts']}")
        logger.info(f"Successful commands: {analysis['summary']['successful_commands']}")
        logger.info(f"Failed commands: {analysis['summary']['failed_commands']}")
        
        if "potential_vectors" in results:
            logger.info(f"Potential vectors found: {analysis['summary']['potential_vectors']}")
        
        if "categories_covered" in results:
            logger.info(f"Categories covered: {analysis['summary']['categories_covered']}")
            logger.info(f"Categories: {', '.join(results['categories_covered'])}")
        
        if "findings" in results and results["findings"]:
            logger.info("\nðŸŽ¯ Key Findings by Category:")
            for category, findings in results["findings"].items():
                logger.info(f"\n{category.upper()}:")
                for finding in findings:
                    logger.info(f"  â€¢ Method: {finding['method']['name']}")
                    logger.info(f"    Indicators: {', '.join(finding['indicators'])}")
        
        if results.get("potential_vectors"):
            logger.info("\nðŸŽ¯ Potential privilege escalation vectors found:")
            for i, vector in enumerate(results["potential_vectors"]):
                logger.info(f"\n{i+1}. {vector['method']['name']}")
                logger.info(f"   Category: {vector['method']['category']}")
                logger.info(f"   Indicators: {', '.join(vector['indicators'])}")
                
                category = vector['method']['category']
                if category == 'unquoted_service_paths':
                    analysis['recommendations'].append("Investigate unquoted service paths for DLL hijacking")
                elif category == 'scheduled_tasks':
                    analysis['recommendations'].append("Check scheduled tasks for privilege escalation opportunities")
                elif category == 'registry_startup':
                    analysis['recommendations'].append("Examine registry entries for persistence or escalation")
                elif category == 'file_permissions':
                    analysis['recommendations'].append("Exploit weak file permissions for privilege escalation")
                elif category == 'service_enum':
                    analysis['recommendations'].append("Analyze service configurations for weak permissions")
                elif category == 'hotfixes':
                    analysis['recommendations'].append("Search for public exploits related to identified hotfixes/KBs.")

        if analysis['recommendations']:
            logger.info("\nðŸ’¡ Recommendations:")
            for i, rec in enumerate(analysis['recommendations']):
                logger.info(f"{i+1}. {rec}")
        
        return analysis
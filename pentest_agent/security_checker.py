import logging
import re

logger = logging.getLogger(__name__)

class SecurityChecker:
    """Safety checks for commands to prevent accidental harm."""

    # List of keywords/commands that are considered dangerous
    BLOCKED_COMMANDS = [
        'del', 'format', 'shutdown', 'restart', 'rm -rf',
        'reg delete', 'bcdedit', 'diskpart', 'cipher /w',
        'erase', 'rd /s /q', # More destructive commands
        'takeown /f /r', # Can break system
        'icacls' # Can break permissions if misused
    ]
    
    # List of patterns that might indicate a potentially dangerous command
    # This list can be expanded and refined.
    DANGEROUS_PATTERNS = [
        r'powershell.*-exec.*bypass', # Execution policy bypass
        r'powershell.*Invoke-Expression', # IEX potentially dangerous
        r'wmic.*shadowcopy.*delete', # Deleting shadow copies
        r'vssadmin.*delete', # Deleting shadow copies
        r'bitsadmin.*download', # Downloading malicious files
        r'certutil.*urlcache.*retrieve', # Downloading malicious files
        r'nc\.exe', # Netcat (often used for reverse shells)
        r'msfvenom', # Metasploit payload generation (if run on target)
        r'shellcode', # Direct shellcode execution
    ]

    @staticmethod
    def is_safe_command(command: str) -> bool:
        """
        Check if a command is safe to execute based on a blocklist and patterns.
        """
        command_lower = command.lower()

        for blocked in SecurityChecker.BLOCKED_COMMANDS:
            if blocked in command_lower:
                logger.warning(f"ðŸš« Command blocked: Contains dangerous keyword '{blocked}'. Command: {command}")
                return False
        
        for pattern in SecurityChecker.DANGEROUS_PATTERNS:
            if re.search(pattern, command_lower):
                logger.warning(f"ðŸš« Command blocked: Matches dangerous pattern '{pattern}'. Command: {command}")
                return False

        logger.debug(f"Command deemed safe: {command}")
        return True